---
layout: post
name: haskell-build-automation-alternatives
title: ! 'Haskell build automation: alternatives to Cabal'
time: 2014-06-12 00:58:00.000000000 -07:00
---
In the <a href="http://ppenzin.github.io/2014/05/26/haskell-build-automation-cabal/">previous post</a> I've talked about issues that Cabal has. Now it is time to talk about what alternatives there are.<br /><h4>Existing tools: task management</h4>Haskell can work with various task automation tools, starting with good old <i>make</i>. Among the tools written in Haskell <a href="https://hackage.haskell.org/package/nemesis">nemesis</a> and <a href="http://hackage.haskell.org/package/shake">shake</a> definitely worth mentioning.<br /><br />One problem with task management tools is that one has to create work flow for them, they don't mandate anything or come with any predefined tasks. A bigger problem is that they still require `global' dependencies, so building with different versions of the same library would be as painful as it is with Cabal.<br /><br />Some workaround would be to create some project-carving tool, like <a href="https://rubygems.org/gems/jeweler">Jeweler</a> or <a href="https://rubygems.org/gems/hoe">Hoe</a> in Ruby. That would introduce a work flow and will set up important tasks, like mandatory testing, but will not help with dependencies.&nbsp;Well, actually the tool can incorporate dependency resolution task, but that will make it almost identical to work flow solutions discussed below.<br /><h4>Solutions yet to be implemented: standard work flow</h4>More drastic approach is to&nbsp;implement a work flow based tool similar to <a href="http://maven.apache.org/">Maven</a>. Standard work flows are a great thing, especially when project needs to be packaged in a particular way, or one wants to ensure that tests are ran every time a build is done.<br /><br />That also has more potential for fixing dependencies, because if fetching dependencies is part of the work flow, then they can be stored and compiled (assuming that they are distributed as source code) locally.<br /><br />As a solution one can implement a Haskell plugin for an existing tool, like Maven or Gradle. That would be as hard as writing it from scratch, since those are heavily geared towards compiling to Java bytecode. Also, those tools are not implemented in Haskell, and I would like to show that Haskell is can stand up to a project like this.<br /><br />So I personally really like the idea of implementing a `conventions and standard work flows' build automation tool in Haskell. I will try to give this a shot, but it will be a big effort, so we'll see what happens.
